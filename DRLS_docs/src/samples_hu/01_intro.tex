\chapter {Bevezetés}
\label{ch:intro}

A szakdolgozatom témáján sokat gondolkoztam. Nem szerettem volna valami sablonos, haszontalan dolgot csinálni, ezért a munkahelyen, ahol dolgoztam ebben az időben beszélgettem a szakdolgozat témaválasztásának nehézségeiről az egyik kiemelkedően jó fejlesztőnkkel, aki akkoriban felettesem és szakmai mentorom volt. Vele átnéztük az egyik termékünket strukturálisan, kielemeztük, hogy milyen hiányosságai vannak, amikre lehetne kész komponens szinten megoldást kialakítani a jelenleg létező, de kiforratlan kezdetleges eszközök, vagy hiányosságok helyett. A projekt struktúrája tartalmazott egy Object Relation Model-t megvalósító belső keretrendszert, ennek segítségével az adatbázisaink rekordjait, tábláit és relációit képeztük le a C++\cite{cpp_docs} nyelvnek létező nyelvi elemeire, ami ezekben az esetekben osztályok objektumpéldányai voltak.

A projekt strukturális felépítéséhez továbbá hozzá tartozott egy aszinkronitást támogató többszálúsítást lehetővé tevő eszközt, amivel taszkokat hozhattunk létre és azokra callback-ekkel iratkozhattunk fel. Az Object Relation Model segítségével létrejövő úgynevezett entitások módosítása innentől kezdve a többszálúsítás hatására veszélyessé vált, ami miatt szükség volt egy eszközre, amin keresztül ezen műveletek szinkronizálása, kölcsönös kizárása megvalósítható. Erre a problémára keretrendszer szinten működő megoldás egy erőforrás zároló rendszer, ami lehetővé teszi ezek biztonságos elvégzését. Ez egy létező eszköz volt a projektben ResourceLockService néven, mely kényelmes és biztonságos módja volt az adatbázisentitásaink kezelésének, viszont bizonyos feladatok elvégzésére nem volt képes.

Ennek a problémakörnek a körbejárása során bukkantunk egy korábban már felmerülő, viszont elhanyagolt igényre, ami az fogalmazta meg, hogy: Legyen lehetőség erőforrások zárolására aszinkron módon, késleltetett végrehajtással ellátva. Az eszköz kapjon egy halmaznyi erőforrást, amit zárol és egy feladatot, amit elvégez. Amennyiben az erőforrások elérhetőek minden gond nélkül lefoglalja őket majd teljesíti a feladatot, amit rá bíztunk. Ha az erőforrások nem elérhetőek akkor a feladatot és az erőforrások halmazát tárolja el, figyelje a felszabaduló erőforrásokat, majd, ha a feladat elvégzéséhez szükséges entitások felszabadulnak, már nem tart fent rájuk semmilyen másik komponens zárat, akkor foglalja le azokat, és végezze el a korábban kapott elvégzendő feladatot. Később felmerülő koncepcionális bővítés keretein belül újabb funkcionalitást is kapott, amely egy időtúllépési limit plusz paramétert jelentett, illetve egy időtúllépés esetén végrehajtandó feladatot, amely szintén plusz paraméterként jelentkezett az eszközben, ezzel növelve annak komplexitását, használhatóságát és értékét a projekt számára. Az elkészítése sok időt energiát és gondolkodást vett igénybe. Az eszköz elkészítését többször kellett újrakezdeni bizonyos rajtam kívül eső okokból, de a kitartás és a szakmai mentorom segítsége a kardinális kérdések eldöntésében meghozta az eredményét és a komponens elkészült.

A munkámra büszke vagyok, és arra is, hogy hasznos részét képezi az egyik igen mély és komplex éles informatikai rendszernek az iparban. Szakdolgozatomban ennek a komponensnek a kipróbáló programját valósítom meg, illetve saját implementációt készítek az ORM\footnote {Object Relation Model} réteghez mivel az túlságosan nagy komponens lett volna a projektből való átemeléshez. A projekt C++ nyelven annak a 20-as szabványában készítem el, a Qt\cite{qt_docs} GUI\footnote {Graphical User Interface} keretrendszer használatával.